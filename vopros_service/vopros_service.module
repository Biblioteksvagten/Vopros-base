<?php

/**
 * @file
 * Module for transfering questions in Vopros.
 */

/**
 * Implements hook_entity_info().
 */
function vopros_service_entity_info() {
  $return = array(
    'vopros_service' => array(
      'label' => t('Vopros Service'),
      'controller class' => 'VoprosServiceEntityController',
      'entity class' => 'VoprosService',
      'base table' => 'vopros_service',
      'revision table' => 'vopros_service_revision',
      'fieldable' => TRUE,
      'entity keys' => array(
        'id' => 'service_id',
        'revision' => 'revision_id',
        'label' => 'label',
      ),
      'bundles' => array(
        'vopros_email' => array(
          'label' => t('Vopros Service'),
          'admin' => array(
            'path' => 'admin/vopros/config/service',
            'access arguments' => array('administer vopros services'),
          ),
        ),
      ),
      'load hook' => 'vopros_service_load',
      'view modes' => array(
        'administrator' => array(
          'label' => t('Administrator'),
          'custom settings' => FALSE,
        ),
      ),
      'module' => 'vopros_service',
      'access callback' => 'vopros_service_access',
      // Allow default views controller to create view data integration.
      'views controller class' => 'EntityDefaultViewsController',
      // Enable the entity API's admin UI.
      'admin ui' => array(
        'path' => 'admin/vopros/services',
        'file' => 'vopros_service.admin.inc',
        'controller class' => 'VoprosServiceUIController',
      ),
    ),
    'vopros_service_message' => array(
      'label' => t('Vopros Service Message'),
      'controller class' => 'VoprosServiceMessageEntityController',
      'entity class' => 'VoprosServiceMessage',
      'base table' => 'vopros_service_message',
      // Vesioning doesn't make sense.
      'fieldable' => FALSE,
      'entity keys' => array(
        'id' => 'service_message_id',
      ),
      'load hook' => 'vopros_service_message_load',
      'view modes' => array(
        'administrator' => array(
          'label' => t('Administrator'),
          'custom settings' => FALSE,
        ),
      ),
      'module' => 'vopros_service',
    ),
  );

  return $return;
}

/**
 * Implements hook_permission().
 */
function vopros_service_permission() {
  $permissions = array(
    'administer vopros services' => array(
      'title' => t('Administer vopros services'),
      'restrict access' => TRUE,
    ),
    'access vopros services' => array(
      'title' => t('Access lists of vopros services, primarily for viewing and referencing'),
    ),
    'create vopros services' => array(
      'title' => t('Create vopros services'),
    ),
    'edit vopros services' => array(
      'title' => t('Edit and delete vopros services'),
      'restrict access' => TRUE,
    ),
    'forward vopros questions' => array(
      'title' => t('Forward questions'),
    ),
  );

  return $permissions;
}


/**
 * Implements hook_menu().
 */
function vopros_service_menu() {
  $items['admin/vopros/questions/%vopros_question/forward'] = array(
    'title' => 'Forward question',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('vopros_service_forward_form', 3),
    'access callback' => 'vopros_service_forward_question_access',
    'access arguments' => array(3),
    'file' => 'vopros_service.pages.inc',
  );

  return $items;
}

/**
 * Implements hook_theme().
 */
function vopros_service_theme() {
  $path = drupal_get_path('module', 'vopros_service') . '/theme';
  return array(
    'vopros_service_message' => array(
      'render element' => 'elements',
      'template' => 'vopros_service_message',
      'path' => $path,
    ),
  );
}

/**
 * Access callback.
 */
function vopros_service_question_access($question = NULL, $account = NULL) {
  global $user;
  $account = isset($account) ? $account : $user;

  // Grant access to any operation for any question for administrators.
  if (user_access('administer questions', $account)) {
    return TRUE;
  }

  if (user_access('forward vopros questions')) {
    if ($question && $question->question_status == 'assigned' && $question->uid != $account->uid) {
      return FALSE;
    }
    return TRUE;
  }
  return FALSE;
}

/**
 * Implements hook_services_resources().
 */
function vopros_service_services_resources() {
  return array(
    'question' => array(
      'operations' => array(
        'create' => array(
          'vopros_access_check' => TRUE,
          'help' => 'Create a new question transfer.',
          'file' => array(
            'type' => 'inc',
            'module' => 'vopros_service',
            'name' => 'resources/vopros_transfer',
          ),
          'callback' => '_vopros_service_resource_retrieve',
          'access callback' => 'vopros_service_resource_access',
          'args' => array(
            array(
              'name' => 'type',
              'optional' => FALSE,
              'source' => array('path' => 0),
              'type' => 'string',
              'description' => 'Type of question "help" or "turn_over".',
            ),
            array(
              'name' => 'question',
              'optional' => FALSE,
              'source' => 'data',
              'type' => 'array',
              'description' => 'The question to create.',
            ),
          ),
        ),
      ),
      'targeted_actions' => array(
        'send_answer' => array(
          'vopros_access_check' => TRUE,
          'help' => 'Send an answer or message to the questioner.',
          'file' => array(
            'type' => 'inc',
            'module' => 'vopros_service',
            'name' => 'resources/vopros_transfer',
          ),
          'callback' => '_vopros_service_resource_send_answer',
          'access callback' => 'vopros_service_resource_access',
          'args' => array(
            array(
              'name' => 'uuid',
              'optional' => FALSE,
              'source' => array('path' => 0),
              'type' => 'string',
              'description' => 'UUID of the original question.',
            ),
            array(
              'name' => 'message',
              'optional' => FALSE,
              'source' => array('data' => 'message'),
              'type' => 'string',
              'description' => 'Message text.',
            ),
            array(
              'name' => 'answer',
              'optional' => TRUE,
              'source' => array('data' => 'answer'),
              'type' => 'string',
              'description' => 'Answer text, optional.',
            ),
          ),
        ),
        'send_message' => array(
          'vopros_access_check' => TRUE,
          'help' => 'Send a message to the helper.',
          'file' => array(
            'type' => 'inc',
            'module' => 'vopros_service',
            'name' => 'resources/vopros_transfer',
          ),
          'callback' => '_vopros_service_resource_send_message',
          'access callback' => 'vopros_service_resource_access',
          'args' => array(
            array(
              'name' => 'uuid',
              'optional' => FALSE,
              'source' => array('path' => 0),
              'type' => 'string',
              'description' => 'UUID of the original question.',
            ),
            array(
              'name' => 'from',
              'optional' => FALSE,
              'source' => array('data' => 'from'),
              'type' => 'string',
              'description' => 'Message from.',
            ),
            array(
              'name' => 'message',
              'optional' => FALSE,
              'source' => array('data' => 'message'),
              'type' => 'string',
              'description' => 'Message text.',
            ),
          ),
        ),
      ),
    ),
  );
}

/**
 * Access check for resource.
 *
 * @todo Currently allows all access, that wont do for production.
 */
function vopros_service_resource_access() {
  return TRUE;
}

/**
 * Implementation of hook_services_authentication_info().
 */
function vopros_service_services_authentication_info() {
  return array(
    'title'             => t('Vopros service authentication'),
    'description'       => t("Use Vopros service authentication."),
    'authenticate_call' => '_vopros_service_authenticate_call',
  );
}

/**
 * Services authentication callback.
 *
 * Checks the request token and sets the current definition if found.
 */
function _vopros_service_authenticate_call($module, $controller, $args) {
  if ($module != 'vopros_service') {
    return;
  }
  $headers = getallheaders();
  if (empty($headers['X-Vopros-Shared-Token'])) {
    return 'Missing auth token.';
  }
  // Find service definition.
  $service_id = db_select('vopros_service', 'v')
    ->fields('v', array('service_id'))
    ->condition('auth_key', $headers['X-Vopros-Shared-Token'])
    ->execute()
    ->fetchField();
  if (empty($service_id)) {
    return "Unknown auth token.";
  }
  $service = vopros_service_load($service_id);

  if (!$service->allow_ingoing) {
    return "Incoming not allowed.";
  }

  vopros_service_current($service);
}

/**
 * Returns the current service definition.
 */
function vopros_service_current($new = NULL) {
  $current = &drupal_static(__FUNCTION__, NULL);
  if ($new) {
    $current = $new;
  }

  return $current;
}

/**
 * Implements hook_vopros_question_view_alter().
 */
function vopros_service_vopros_question_view_alter(&$build, $entity_type) {
  $question = $build['#question'];
  $forward = db_select('vopros_service_question', 'q')
    ->fields('q')
    ->condition('uuid', $question->uuid)
    ->execute()
    ->fetch();

  if (empty($forward)) {
    return;
  }

  // outgoing help = sidebar
  // incoming help = main content
  // * turn_over = don't show anything
  if ($forward->type == 'help') {
    $build['#attached']['css'][] = drupal_get_path('module', 'vopros_service') . '/css/vopros_service.admin.css';

    $message_ids = db_select('vopros_service_message', 'q')
      ->fields('q', array('service_message_id'))
      ->condition('question_id', $question->question_id)
      ->orderBy('created')
      ->execute()
      ->fetchCol();
    $messages = entity_load('vopros_service_message', $message_ids);
    $messages_build = entity_view('vopros_service_message', $messages, $build['#view_mode']);
    $messages_build += array(
      '#prefix' => '<div class=question-messages>',
      '#suffix' => '</div>',
      '#weight' => 10,
    );
    if ($forward->direction == 'outgoing') {
      // For outgoing help, they should be shown in right column.
      $build['right']['question_messages'] = $messages_build;
      module_load_include('inc', 'vopros_service', 'vopros_service.form');
      $build['right']['question_messages_form'] = drupal_get_form('vopros_service_message_form', $forward);
      $build['right']['question_messages_form']['#weight'] = 11;
    }
    else {
      // Otherwise just append.
      $build['question_messages'] = $messages_build;
    }
  }
  // dpm($build);
}


/**
 * Implements hook_form_FORM_ID_alter().
 */
function vopros_service_form_vopros_question_handle_question_form_alter(&$form, $form_state) {
  $question = $form['question']['#value'];
  $forwards = db_select('vopros_service_question', 'v')
    ->fields('v')
    ->condition('uuid', $question->uuid)
    ->execute()
    ->fetchAllAssoc('type');

  // For now we only allow forwarding when the question when the question isn't
  // already forwarded. This might be changed later.
  if (empty($forwards)) {
    $form['actions']['forward'] = array(
      '#type' => 'submit',
      '#value' => t('Forward question'),
      '#weight' => 1,
      '#submit' => array('vopros_service_question_view_form_submit'),
    );
  }
}

/**
 * Submit handler for the forward button.
 *
 * Redirects to the forward form.
 */
function vopros_service_question_view_form_submit($form, &$form_state) {
  $question = $form['question']['#value'];
  $url = entity_uri('vopros_question', $question);
  $url['path'] .= '/forward';
  $form_state['redirect'] = array($url['path'] , $url['options']);
}

/**
 * Checks email access for various operations.
 *
 * @param $op
 *   The operation being performed. One of 'view', 'update', 'create' or
 *   'delete'.
 * @param $service
 *   Optionally a vopros service to check access for.
 * @param $account
 *   The user to check for. Leave it to NULL to check for the current user.
 */
function vopros_service_access($op, $service = NULL, $account = NULL) {
  global $user;
  $account = isset($account) ? $account : clone($user);

  // Grant access to any operation for any vopros service for administrators.
  if (user_access('administer vopros services', $account)) {
    return TRUE;
  }

  // Grant view access to users with the administrative access orders permission
  // or to a user's own orders with the view own orders permission.
  if ($op == 'view') {
    if (user_access('access vopros services', $account)) {
      return TRUE;
    }
  }

  if ($op == 'create' && user_access('create vopros services', $account)) {
    return TRUE;
  }

  if ($op == 'update' || $op == 'delete') {
    if (user_access('edit vopros services', $account)) {
      return TRUE;
    }
  }

  return FALSE;
}

/**
 * Create a new vopros service object.
 */
function vopros_service_new($values = array()) {
  return entity_create('vopros_email', $values);
}

/**
 * Loads a vopros service by ID.
 */
function vopros_service_load($service_id, $reset = FALSE) {
  $services = vopros_service_load_multiple(array($service_id), array(), $reset);
  return $services ? reset($services) : FALSE;
}

/**
 * Loads a vopros service by machine name.
 */
function vopros_service_machine_name_load($machine_name, $reset = FALSE) {
  $services = vopros_service_load_multiple(FALSE, array('machine_name' => $machine_name), (bool) $reset);
  return $services ? reset($services) : FALSE;
}

/**
 * Loads multiple vopros services by ID or based on a set of matching
 * conditions.
 *
 * @see entity_load()
 *
 * @param $service_ids
 *   An array of service IDs.
 * @param $conditions
 *   An array of conditions on the {vopros_service} table in the form
 *     'field' => $value.
 * @param $reset
 *   Whether to reset the internal email loading cache.
 *
 * @return
 *   An array of email objects indexed by email_id.
 */
function vopros_service_load_multiple($service_ids = FALSE, $conditions = array(), $reset = FALSE) {
  return entity_load('vopros_service', $service_ids, $conditions, $reset);
}

/**
 * Implements hook_vopros_question_status_reasons_alter().
 */
function vopros_service_vopros_question_status_reasons_alter(&$reasons) {
  $reasons['handed over to external service'] = t('Handed over to external service');
  $reasons['reactivated by external service'] = t('Reactivated by external service');

}

/**
 * Implements hook_vopros_question_qanda_serice_options().
 */
function vopros_service_vopros_question_qanda_serice_options_alter(&$options) {
  $services = vopros_service_load_multiple(FALSE, array('allow_ingoing' => 1));
  foreach ($services as $service_id => $service) {
    $options['vopros_service_' . $service_id] = $service->label();
  }
}

/**
 * Forward a question to another Vopros installation.
 *
 * @param VoprosService $service
 *   The service definition.
 * @param string $type
 *   The type of the forward, 'help' or 'turn_over'.
 * @param VoprosQuestion $question
 *   The question to forward.
 * @param string $message
 *   A message for the receiver.
 *
 * @return bool
 *   Whether the question was successfully submitted.
 */
function _vopros_service_forward_question($service, $type, $question, $message) {
  // Prepare data. Basic data.
  $data = array(
    'uuid' => $question->uuid,
    'question_title' => $question->question_title,
    'question_content' => $question->question_content,
    'question_deadline' => $question->question_deadline,
    'question_deadline_timestamp' => $question->question_deadline_timestamp,
    'question_usage' => $question->question_usage,
    'message' => $message,
  );

  if ($type == 'turn_over') {
    // Add in user data.
    $data['user_name'] = $question->user_name;
    $data['user_email'] = $question->user_email;
    $data['user_postal_code'] = $question->user_postal_code;
    $data['user_mobile_phone'] = $question->user_mobile_phone;
    $data['user_age'] = $question->user_age;
    $data['user_gender'] = $question->user_gender;
    $data['user_field_of_study'] = $question->user_field_of_study;
    $data['user_library'] = $question->user_library;
    $data['user_answer_preference'] = $question->user_answer_preference;
  }

  return _vopros_service_do_request($service, '/question/' . $type, 'POST', $data);
}

/**
 * Send a question message to another Vopros installation.
 *
 * @param VoprosService $service
 *   The service to send to.
 * @param VoprosQuestion $question
 *   The question to send a message on.
 * @param string $message
 *   The message to send.
 */
function _vopros_service_send_message($service, $question, $message) {
  return _vopros_service_do_request($service, '/question/' . $question->uuid . '/send_message', 'POST', $message);
}

/**
 * Internal helper function for doing the service call.
 */
function _vopros_service_do_request($service, $path, $method, $data) {
  $url = trim($service->url, '/') . $path;
  $options = array(
    'method' => $method,
    'headers' => array(
      'Content-Type' => 'application/json',
      'X-Vopros-Shared-Token'  => $service->auth_key,
    ),
    'data' => drupal_json_encode($data),
  );

  $res = drupal_http_request($url, $options);

  if ($res->code == 200) {
    return TRUE;
  }
  else {
    if (!empty($res->data)) {
      $error = drupal_json_decode($res->data);
      if (!empty($error[0])) {
        _vopros_service_error($error[0]);
      }
      else {
        _vopros_service_error($res->data);
      }
    }
    else  {
      _vopros_service_error($res->error);
    }
    return FALSE;
  }
}


/**
 * Returns the last error from service call.
 */
function _vopros_service_error($new = NULL) {
  $error = &drupal_static(__FILE__, NULL);
  if ($new) {
    $error = $new;
  }
  return $error;
}
