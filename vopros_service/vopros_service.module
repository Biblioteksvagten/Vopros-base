<?php

/**
 * @file
 * Module for transfering questions in Vopros.
 */

/**
 * Implements hook_entity_info().
 */
function vopros_service_entity_info() {
  $return = array(
    'vopros_service' => array(
      'label' => t('Vopros Service'),
      'controller class' => 'VoprosServiceEntityController',
      'entity class' => 'VoprosService',
      'base table' => 'vopros_service',
      'revision table' => 'vopros_service_revision',
      'fieldable' => TRUE,
      'entity keys' => array(
        'id' => 'service_id',
        'revision' => 'revision_id',
        'label' => 'label',
      ),
      'bundles' => array(
        'vopros_email' => array(
          'label' => t('Vopros Service'),
          'admin' => array(
            'path' => 'admin/vopros/config/service',
            'access arguments' => array('administer vopros services'),
          ),
        ),
      ),
      'load hook' => 'vopros_service_load',
      'view modes' => array(
        'administrator' => array(
          'label' => t('Administrator'),
          'custom settings' => FALSE,
        ),
      ),
      'module' => 'vopros_service',
      'access callback' => 'vopros_service_access',
      // Allow default views controller to create view data integration.
      'views controller class' => 'EntityDefaultViewsController',
      // Enable the entity API's admin UI.
      'admin ui' => array(
        'path' => 'admin/vopros/services',
        'file' => 'vopros_service.admin.inc',
        'controller class' => 'VoprosServiceUIController',
      ),
    ),
  );

  return $return;
}

/**
 * Implements hook_permission().
 */
function vopros_service_permission() {
  $permissions = array(
    'administer vopros services' => array(
      'title' => t('Administer vopros services'),
      'restrict access' => TRUE,
    ),
    'access vopros services' => array(
      'title' => t('Access lists of vopros services, primarily for viewing and referencing'),
    ),
    'create vopros services' => array(
      'title' => t('Create vopros services'),
    ),
    'edit vopros services' => array(
      'title' => t('Edit and delete vopros services'),
      'restrict access' => TRUE,
    ),
    'forward vopros questions' => array(
      'title' => t('Forward questions'),
    ),
  );

  return $permissions;
}


/**
 * Implements hook_menu().
 */
function vopros_service_menu() {
  $items['admin/vopros/questions/%vopros_question/forward'] = array(
    'title' => 'Forward question',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('vopros_service_forward_form', 3),
    'page arguments' => array('vopros_service_question_service_form', 3),
    'access callback' => 'vopros_service_question_access',
    'file' => 'vopros_service.pages.inc',
  );

  return $items;
}

/**
 * Access callback.
 */
function vopros_service_question_access($op, $question = NULL, $account = NULL) {
  global $user;
  $account = isset($account) ? $account : clone($user);

  // Grant access to any operation for any question for administrators.
  if (user_access('administer questions', $account)) {
    return TRUE;
  }

  if (user_access('forward vopros questions')) {
    if ($question && $question->question_status == 'assigned' && $question->uid != $account->uid) {
      return FALSE;
    }
    return TRUE;
  }
  return FALSE;
}

/**
 * Implements hook_services_resources().
 */
function vopros_service_services_resources() {
  return array(
    'question' => array(
      'operations' => array(
        'create' => array(
          'help' => 'Create a new question transfer.',
          'file' => array(
            'type' => 'inc',
            'module' => 'vopros_service',
            'name' => 'resources/vopros_transfer',
          ),
          'callback' => '_vopros_service_resource_retrieve',
          'access callback' => 'vopros_service_resource_access',
          'args' => array(
            array(
              'name' => 'type',
              'optional' => FALSE,
              'source' => array('path' => 0),
              'type' => 'string',
              'description' => 'Type of question "help" or "turn_over".',
            ),
            array(
              'name' => 'question',
              'optional' => FALSE,
              'source' => 'data',
              'type' => 'array',
              'description' => 'The question to create.',
            ),
          ),
        ),
      ),
      'targeted_actions' => array(
        'send_answer' => array(
          'help' => 'Send an answer or message to the questioner.',
          'file' => array(
            'type' => 'inc',
            'module' => 'vopros_service',
            'name' => 'resources/vopros_transfer',
          ),
          'callback' => '_vopros_service_resource_send_answer',
          'access callback' => 'vopros_service_resource_access',
          'args' => array(
            array(
              'name' => 'uuid',
              'optional' => FALSE,
              'source' => array('path' => 0),
              'type' => 'string',
              'description' => 'UUID of the original question.',
            ),
            array(
              'name' => 'message',
              'optional' => FALSE,
              'source' => array('data' => 'message'),
              'type' => 'string',
              'description' => 'Message text.',
            ),
            array(
              'name' => 'answer',
              'optional' => TRUE,
              'source' => array('data' => 'answer'),
              'type' => 'string',
              'description' => 'Answer text, optional.',
            ),
          ),
        ),
        'send_message' => array(
          'help' => 'Send a message to the helper.',
          'file' => array(
            'type' => 'inc',
            'module' => 'vopros_service',
            'name' => 'resources/vopros_transfer',
          ),
          'callback' => '_vopros_service_resource_send_message',
          'access callback' => 'vopros_service_resource_access',
          'args' => array(
            array(
              'name' => 'uuid',
              'optional' => FALSE,
              'source' => array('path' => 0),
              'type' => 'string',
              'description' => 'UUID of the original question.',
            ),
            array(
              'name' => 'message',
              'optional' => FALSE,
              'source' => array('data' => 'message'),
              'type' => 'string',
              'description' => 'Message text.',
            ),
          ),
        ),
      ),
    ),
  );
}

/**
 * Access check for resource.
 *
 * @todo Currently allows all access, that wont do for production.
 */
function vopros_service_resource_access() {
  return TRUE;
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function vopros_service_form_vopros_question_handle_question_form_alter(&$form, $form_state) {
  $question = $form['question']['#value'];
  $forwards = db_select('vopros_service_question', 'v')
    ->fields('v')
    ->condition('uuid', $question->uuid)
    ->execute()
    ->fetchAllAssoc('type');

  // For now we only allow forwarding when the question when the question isn't
  // already forwarded. This might be changed later.
  if (empty($forwards)) {
    $form['actions']['forward'] = array(
      '#type' => 'submit',
      '#value' => t('Forward question'),
      '#weight' => 1,
      '#submit' => array('vopros_service_question_view_form_submit'),
    );
  }
}

/**
 * Submit handler for the forward button.
 *
 * Redirects to the forward form.
 */
function vopros_service_question_view_form_submit($form, &$form_state) {
  $question = $form['question']['#value'];
  $url = entity_uri('vopros_question', $question);
  $url['path'] .= '/forward';
  $form_state['redirect'] = array($url['path'] , $url['options']);
}

/**
 * Checks email access for various operations.
 *
 * @param $op
 *   The operation being performed. One of 'view', 'update', 'create' or
 *   'delete'.
 * @param $service
 *   Optionally a vopros service to check access for.
 * @param $account
 *   The user to check for. Leave it to NULL to check for the current user.
 */
function vopros_service_access($op, $service = NULL, $account = NULL) {
  global $user;
  $account = isset($account) ? $account : clone($user);

  // Grant access to any operation for any vopros service for administrators.
  if (user_access('administer vopros services', $account)) {
    return TRUE;
  }

  // Grant view access to users with the administrative access orders permission
  // or to a user's own orders with the view own orders permission.
  if ($op == 'view') {
    if (user_access('access vopros services', $account)) {
      return TRUE;
    }
  }

  if ($op == 'create' && user_access('create vopros services', $account)) {
    return TRUE;
  }

  if ($op == 'update' || $op == 'delete') {
    if (user_access('edit vopros services', $account)) {
      return TRUE;
    }
  }

  return FALSE;
}

/**
 * Create a new vopros service object.
 */
function vopros_service_new($values = array()) {
  return entity_create('vopros_email', $values);
}

/**
 * Loads a vopros service by ID.
 */
function vopros_service_load($service_id, $reset = FALSE) {
  $services = vopros_service_load_multiple(array($service_id), array(), $reset);
  return $services ? reset($services) : FALSE;
}

/**
 * Loads a vopros service by machine name.
 */
function vopros_service_machine_name_load($machine_name, $reset = FALSE) {
  $services = vopros_service_load_multiple(FALSE, array('machine_name' => $machine_name), (bool) $reset);
  return $services ? reset($services) : FALSE;
}

/**
 * Loads multiple vopros services by ID or based on a set of matching
 * conditions.
 *
 * @see entity_load()
 *
 * @param $service_ids
 *   An array of service IDs.
 * @param $conditions
 *   An array of conditions on the {vopros_service} table in the form
 *     'field' => $value.
 * @param $reset
 *   Whether to reset the internal email loading cache.
 *
 * @return
 *   An array of email objects indexed by email_id.
 */
function vopros_service_load_multiple($service_ids = FALSE, $conditions = array(), $reset = FALSE) {
  return entity_load('vopros_service', $service_ids, $conditions, $reset);
}

/**
 * Defines the possible auth types
 */
function vopros_service_auth_types() {
  return array(
    'secret_key' => t('Secret key'),
  );
}

/**
 * Implements hook_vopros_question_status_reasons_alter().
 */
function vopros_service_vopros_question_status_reasons_alter(&$reasons) {
  $reasons['turned over to external service'] = t('Turned over to external service');
}

/**
 * Forward a question to another Vopros installation.
 *
 * @param VoprosService $service
 *   The service definition.
 * @param string $type
 *   The type of the forward, 'help' or 'turn_over'.
 * @param VoprosQuestion $question
 *   The question to forward.
 * @param string $message
 *   A message for the receiver.
 *
 * @return bool
 *   Whether the question was successfully submitted.
 */
function _vopros_service_forward_question($service, $type, $question, $message) {
  }

  $url = trim($service->url, '/') . '/question/' . $type;
  $options = array(
    'method' => 'POST',
    'headers' => array(
      'Content-Type' => 'application/json',
    ),
    'data' => json_encode($question),
  );

  $res = drupal_http_request($url, $options);

  if ($res->code == 200) {
    return TRUE;
  }
  else {
    dpm($res, $res->error);
    return FALSE;
  }
}
